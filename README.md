# juiz - the robot middleware

# Motivation

まず、このソフトウェアを作った動機を書いておく。

このソフトウェアに興味を持った人ならROSの存在は知っていると思う。
ロボットのソフトウェアを作るためのデファクトスタンダードとなっているソフトウェア基盤だ。
私はこのROSについて大きな不満があるわけではない。
もちろん小さな不満はたくさんあって、集めれば大きな不満2つか3つ分にはなるだろうが、些細なことだ。
いまとりあえず実験したい、再診の研究をキャッチアップしたい、などのプロトタイピング目的でROSを使うのは賛成する。

一方で、ROSはバージョン2においても、古典的かつ曖昧なプログラミングモデルを引き続き許しており、ROSを使って継続的に発展するソフトウェア開発を行う場合はリスクが伴う。
大きなリスクとして、モジュールの大きさについて明確な定義や指針がないまま、ソフトウェアの状態をカプセル化している点である。
ROSに限らず、状態をカプセル化するソフトウェアモジュールは継続的発展を経ると肥大化する傾向があり、より多くの状態を包含して複雑化する。
これを避けるためにSOLIDなどの開発指針を厳格に導入が、ソフトウェア内部に加えてコンポーネント設計のレベルにおいても重要であるが、ロボットに関わる開発エンジニアチームのソフトウェアリテラシーを高く維持するのは難しい。

一方でウェブなど、ロボット開発と比較してソフトウェアの新陳代謝が活発な世界では、コンポーネントの可搬性はそのままに、内包する状態を集中管理するためのインフラ整備や、状態を積極的に交換するための共通APIを用意することが一般的になっている。
たとえば、ウェブフロントエンドでスタンダードの1つとなっているフレームワークのReactを例に挙げてみる。
Reactはキャンバスやボタン、テキストフィールドなどのHTML部品と、その動作を司るJavascriptないしはTypescriptのコードを一つのコンポーネントとしてまとめ、このコンポーネントを組み合わせてまた大きなコンポーネントや、ウェブページを構成するソフトウェアフレームワークである。
Reactでは内部状態をstateという変数を介してコンポーネント内部の状態の読み書きや自動更新を管理しているが、しばしばこの状態を上位のコンポーネントや、隣り合うコンポーネントとやり取りするために多くのコードを書く必要があった。
これに対して、複数の状態管理フレームワークが提案されている。
例えば、事実上の標準となっているReduxでは、Fluxアーキテクチャと呼ばれる、ソフトウェア全体の状態を集中管理しつつ、状態の読み書きのデータの流れを一方通行にすることで単純化している。
Metaが開発しているRecoilでは、グローバルなキーに紐付けられた状態を任意のタイミングで取得し、また同時に得られるアクセサーで更新することで状態をReduxに比べると分散的に管理している。

このように、ソフトウェア規模が大きくなるとコンポーネントが内包する状態を隠蔽しすぎることの弊害が指摘される一方で、ROSに見られるコンポーネント型かつ比較的厳格な直積型データ型を利用するアーキテクチャでは、心筋梗塞を起こしやすい。
ROSでは内部状態を表す変数を他のソフトウェアと共有するためには、Topic、ActionおよびServiceが利用される。
Topicはpush型のデータフロー型通信を提供する。送信側は受信側の状態等を意識する必要は無いが、受信側から制御するのは難しい。
Serviceは遠隔呼び出し型通信で、クライアント・サーバー的なデータ交換を提供する。
クライアント側からのサービスの呼び出しには引数を与えることが出来、結果としてデータを受信できる。
またActionはServiceの発展版と言える通信で、結果の受信まで時間の掛かる遠隔呼び出し通信において、途中経過をFeedbackと言う形で受け取ることが出来る。
またモジュール外部からデータを受け取る仕組みとしてdynamic configureが用意されている。
これらはすべてデータの交換を目的として居ながら複数の仕組みが提供されている点で冗長であり、設計時の選択が必要な点で複雑である。

